name: Sync Backlog (milestones/labels)

on:
  workflow_dispatch: {}

permissions:
  issues: write
  contents: read

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Sync milestones and labels, update issues by title
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const data = JSON.parse(fs.readFileSync('.github/backlog.json', 'utf8'));

            // Milestones ensure
            const existingMilestonesAll = await github.paginate(github.rest.issues.listMilestones, { owner: context.repo.owner, repo: context.repo.repo, state: 'all' });
            let milestoneMap = new Map(existingMilestonesAll.map(m => [m.title, m]));
            for (const m of data.milestones || []) {
              if (!milestoneMap.has(m.title)) {
                const created = await github.rest.issues.createMilestone({ owner: context.repo.owner, repo: context.repo.repo, title: m.title, description: m.description || '' });
                milestoneMap.set(created.data.title, created.data);
              } else if (milestoneMap.get(m.title).state === 'closed') {
                const reopened = await github.rest.issues.updateMilestone({ owner: context.repo.owner, repo: context.repo.repo, milestone_number: milestoneMap.get(m.title).number, state: 'open' });
                milestoneMap.set(reopened.data.title, reopened.data);
              }
            }

            // Labels ensure
            const existingLabels = await github.paginate(github.rest.issues.listLabelsForRepo, { owner: context.repo.owner, repo: context.repo.repo });
            const labelSet = new Set(existingLabels.map(l => l.name));
            const labelColors = {
              bug: 'd73a4a', enhancement: 'a2eeef', task: 'bfdadc', ci: 'c5def5', database: 'f9d0c4', test: 'e4e669', files: 'fef2c0', search: 'a4f287', reporting: 'c2e0c6', notifications: 'cfd3ff', sso: 'c0ffee', security: 'b60205', performance: 'ffd78e', ops: 'd4c5f9', docs: '0075ca', api: '0366d6', frontend: '0e8a16', design: 'fbca04', M0: 'ededed'
            };
            for (const name of Object.keys(labelColors)) {
              if (!labelSet.has(name)) {
                await github.rest.issues.createLabel({ owner: context.repo.owner, repo: context.repo.repo, name, color: labelColors[name] });
                labelSet.add(name);
              }
            }

            // Map existing issues by title
            const existingIssues = await github.paginate(github.rest.issues.listForRepo, { owner: context.repo.owner, repo: context.repo.repo, state: 'all' });
            const byTitle = new Map(existingIssues.map(i => [i.title, i]));

            for (const spec of data.issues || []) {
              const targetMilestone = milestoneMap.get(spec.milestone);
              const labels = spec.labels || [];
              if (byTitle.has(spec.title)) {
                const current = byTitle.get(spec.title);
                const currentLabels = new Set(current.labels.map(l => l.name));
                const missing = labels.filter(l => !currentLabels.has(l));
                // Ensure labels exist on issue
                if (missing.length > 0) {
                  await github.rest.issues.addLabels({ owner: context.repo.owner, repo: context.repo.repo, issue_number: current.number, labels: missing });
                }
                // Update milestone if different
                const currMsTitle = current.milestone?.title;
                if (targetMilestone && currMsTitle !== targetMilestone.title) {
                  await github.rest.issues.update({ owner: context.repo.owner, repo: context.repo.repo, issue_number: current.number, milestone: targetMilestone.number });
                }
              } else {
                await github.rest.issues.create({ owner: context.repo.owner, repo: context.repo.repo, title: spec.title, body: spec.body || '', labels, milestone: targetMilestone?.number });
              }
            }

